#!/usr/bin/env scala

import java.io._

val mav = "mavros_msgs"
val msgs = new File(mav + "/" + "msg/").listFiles.toList
val srvs = new File(mav + "/" + "srv/").listFiles.toList

val constant = raw"(\S+)\s(\S+)=(\S+)$$".r
val data = raw"(\S+)\s([^\s=]+)$$".r

var names: List[String] = List()

for (msg <- msgs) {
  
  val str = msgToScala(msg)
  writeFile(msg, str)
  names ::= getName(msg)
}

for (srv <- srvs) {
  
  val str = srvToScala(srv)
  writeFile(srv, str)
  names ::= getName(srv)
}

val mavrosExp = "trait MavrosExp extends " + names.map(_+"Exp").mkString(" with ") + "{ self: RosExp => }"
val mavrosApi = "trait MavrosApi extends " + names.map(_+"Api").mkString(" with ") + "{ self: RosApi => }"
val mavF = new File("Mavros.scala")
writeFile(mavF, "package spatial.ros\n\n" + mavrosExp + "\n\n" + mavrosApi)

def getName(file: File) =
  remap(file.getName.split('.')(0))

def quote(s:String) = s match {
  case "type" => "`type`"
  case _ => s
}
def remap(tp: String) = {
  val t = tp.split('/').last.takeWhile(_ != '[') match {
    case "Quaternion" => "Quaternion"                
    case "Point" => "Point"            
    case "Vector3" => "Vec3"
    case "ParamValue" => "ParamValue"          
    case "FileEntry" => "FileEntry"    
    case "Waypoint" => "Waypoint"
    case "bool" => "Bool"
    case "float32" => "FltPt[_24,_8]"
    case "float64" => "FltPt[_53,_11]"      
    case "int8" => "FixPt[TRUE,_8,_0]"
    case "int16" => "FixPt[TRUE,_16,_0]"
    case "int32" => "FixPt[TRUE,_32,_0]"      
    case "int64" => "FixPt[TRUE,_64,_0]"
    case "uint8" => "FixPt[FALSE,_8,_0]"
    case "uint16" => "FixPt[FALSE,_16,_0]"
    case "uint32" => "FixPt[FALSE,_32,_0]"      
    case "uint64" => "FixPt[FALSE,_64,_0]"            
    case "string" => "Text"
    case _ => tp
  }

  var toStrip = tp
  var r = t
  while (toStrip.takeRight(2) == "[]") {
    toStrip = toStrip.dropRight(2)
    r = "MetaArray["+r+"]"
  }
  r
}

def ident(x: Seq[Any], tab: Int) =
  x.map(" "*(2*tab) + _).mkString("\n")

def msgToScala(f: File) = {
  val lines = io.Source.fromFile(f).getLines.filterNot(_.startsWith("#")).toList
  val name = getName(f)
  println(name)

  val constants = lines collect {
    case constant(a, b, c) => (a, b, c)
  }

  val datas = lines collect {
    case data(a, b) if !a.contains("Header") => (a, b)
  }

  val apis = datas.map { case (t, n) =>
    s"@api def ${quote(n)}: ${remap(t)} = ???"
  }
  val nodes = datas map { case (t, n) =>
    s"""
case class ${name}_${n}(msg: Exp[$name]) extends Op[${remap(t)}] {
  def mirror(f: Tx) = stage(${name}_${n}(f(msg)))(EmptyContext)
}
"""
  }
  
  val cs = constants.map { case (t, n, v) =>
    s"val ${quote(n)}: ${remap(t)} = $v"
  }

s"""
package spatial.ros

import forge._
import org.virtualized._

trait ${name}Api extends ${name}Exp {
  self: RosApi =>

}

trait ${name}Exp {
  self: RosExp =>

  implicit object ${name}Type extends Meta[$name] {
    def wrapped(x: Exp[$name]) = $name(x)
    def stagedClass = classOf[$name]
    def isPrimitive = false
  }

  case class $name(s: Exp[$name]) extends MetaAny[$name] {
${ident(apis, 2)}
    @api def ===(that: $name) = ???
    @api def =!=(that: $name) = ???
    @api def toText: Text = ???
  }

${ident(nodes, 1)}
  
  object $name {
${ident(cs, 2)}
  }

}
"""
}

def srvToScala(f: File) = {
  val lines = io.Source.fromFile(f).getLines.filterNot(_.startsWith("#")).toList
  val (req, repP) = lines.splitAt(lines.indexOf("---"))
  val rep = repP.drop(1)
  val name = getName(f)
  val nameRep = name+"Rep"

  val constants = req collect {
    case constant(a, b, c) => (a, b, c)
  }

  val datas = req collect {
    case data(a, b) if !a.contains("Header") => (a, b)
  }

  val constantsRep = rep collect {
    case constant(a, b, c) => (a, b, c)
  }

  val datasRep = rep collect {
    case data(a, b) if !a.contains("Header") => (a, b)
  }

  val apis = datas map { case (t, n) =>
    s"@api def ${quote(n)}: ${remap(t)} = ???"
  }
  val apisRep = datasRep map { case (t, n) =>
    s"@api def ${quote(n)}: ${remap(t)} = ???"
  }
  val nodes = datas map { case (t, n) =>
    s"""
case class ${name}_${n}(srv: Exp[$name]) extends Op[${remap(t)}] {
  def mirror(f: Tx) = stage(${name}_${n}(f(srv)))(EmptyContext)
}
"""
  }
  val nodesRep = datas map { case (t, n) =>
    s"""
case class ${nameRep}_${n}(srv: Exp[$nameRep]) extends Op[${remap(t)}] {
  def mirror(f: Tx) = stage(${nameRep}_${n}(f(srv)))(EmptyContext)
}
"""
  }
  val cs = constants map { case (t, n, v) =>
    s"val ${quote(n)}: ${remap(t)} = $v"
  }
  val csRep = constantsRep map { case (t, n, v) =>
    s"val ${quote(n)}: ${remap(t)} = $v"
  }


s"""
package spatial.ros

import forge._
import org.virtualized._

trait ${name}Api extends ${name}Exp {
  self: RosApi =>

}

trait ${name}Exp {
  self: RosExp =>
  
  implicit object ${name}Type extends Meta[$name] {
    def wrapped(x: Exp[$name]) = $name(x)
    def stagedClass = classOf[$name]
    def isPrimitive = false
  }

  implicit object ${nameRep}Type extends Meta[$nameRep] {
    def wrapped(x: Exp[$nameRep]) = $nameRep(x)
    def stagedClass = classOf[$nameRep]
    def isPrimitive = false
  }

  case class $name(s: Exp[$name]) extends MetaAny[$name] {
${ident(apis, 2)}
    @api def response: $nameRep = ???//$nameRep(${name}Reply(s))
    @api def ===(that: $name): Bool = ???
    @api def =!=(that: $name): Bool = ???
    @api def toText: Text = ???
  }

  case class $nameRep(s: Exp[$nameRep]) extends MetaAny[$nameRep] {
${ident(apisRep, 2)}
    @api def ===(that: $nameRep): Bool = ???
    @api def =!=(that: $nameRep): Bool = ???
    @api def toText: Text = ???
  }

${ident(nodes, 1)}
${ident(nodesRep, 1)}
  case class ${name}Reply(srv: Exp[$name]) extends Op[$nameRep]{
    def mirror(f: Tx) = stage(${name}Reply(f(srv)))(EmptyContext)
  }

  
  object $name {
${ident(cs, 2)}
  }

  object $nameRep {
${ident(csRep, 2)}
  }

}
"""  
}
def writeFile(f: File, s: String) = {
  val name = getName(f)
  val out = new File("ros/src/main/scala/mavros_msgs/"+ name +".scala")
  out.mkdirs()
  if (out.exists)
    out.delete()
  out.createNewFile
  val pw = new PrintWriter(out)
  pw.println(s)
  pw.close()
}

